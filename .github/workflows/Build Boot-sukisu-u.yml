name: Build Boot Image (NDK Clang + SukiSU Option)

# 仅手动触发
on:
  workflow_dispatch:
    inputs:
      kernel_branch:
        description: '内核源码分支'
        required: true
        default: 'lineage-22.2'
        type: string
      device_codename:
        description: '设备代号（如 pdx234）'
        required: true
        default: 'pdx234'
        type: string
      build_type:
        description: '编译类型'
        required: true
        default: 'original'
        type: choice
        options:
          - original  # 原内核（无 SukiSU）
          - with_sukisu  # 带 SukiSU 内核

jobs:
  # --------------------------
  # Job 1：依赖准备与缓存（NDK Clang + SukiSU）
  # --------------------------
  prepare-dependencies:
    runs-on: ubuntu-22.04
    outputs:
      device_codename: ${{ github.event.inputs.device_codename || 'pdx234' }}
      kernel_branch: ${{ github.event.inputs.kernel_branch || 'lineage-22.2' }}
      build_type: ${{ github.event.inputs.build_type || 'original' }}
    steps:
      - name: Checkout main repo
        uses: actions/checkout@v4

      - name: Install download dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y git git-lfs wget curl lz4 patch unzip  # 恢复unzip（解压缩NDK）

      # 1. 缓存内核源码（含SukiSU补丁区分）
      - name: Cache kernel source
        id: cache-kernel
        uses: actions/cache@v3
        with:
          path: ./kernel
          key: kernel-${{ github.event.inputs.kernel_branch }}-${{ github.event.inputs.device_codename }}-${{ github.event.inputs.build_type }}-${{ runner.os }}
          restore-keys: |
            kernel-${{ github.event.inputs.kernel_branch }}-${{ github.event.inputs.device_codename }}-${{ github.event.inputs.build_type }}-

      - name: Clone kernel source (if not cached)
        if: steps.cache-kernel.outputs.cache-hit != 'true'
        run: |
          KERNEL_REPO="https://github.com/LineageOS/android_kernel_sony_sm8550.git"
          KERNEL_BRANCH="${{ github.event.inputs.kernel_branch || 'lineage-22.2' }}"
          git clone $KERNEL_REPO kernel
          cd kernel && git checkout $KERNEL_BRANCH && git rev-parse HEAD > ../kernel_commit.txt

      # 2. 集成 SukiSU（仅with_sukisu时执行）
      - name: Integrate SukiSU (if build type is with_sukisu)
        if: github.event.inputs.build_type == 'with_sukisu'
        run: |
          cd kernel
          # 执行SukiSU补丁脚本
          curl -LSs "https://raw.githubusercontent.com/SukiSU-Ultra/SukiSU-Ultra/main/kernel/setup.sh" | bash -s main
          
          # 提取SukiSU版本
          if [ -f ./include/config/sukisu.h ]; then
            SUKISU_VERSION=$(grep "SUKISU_VERSION" ./include/config/sukisu.h | cut -d '"' -f2)
          elif [ -f ./include/config/kernelsu.h ]; then
            SUKISU_VERSION=$(grep "KSU_VERSION" ./include/config/kernelsu.h | cut -d '"' -f2)
          else
            SUKISU_VERSION="unknown"
          fi
          echo "SUKISU_VERSION=$SUKISU_VERSION" >> $GITHUB_ENV

      # 3. 缓存设备树
      - name: Cache device trees
        id: cache-device
        uses: actions/cache@v3
        with:
          path: |
            ./device/sony/${{ github.event.inputs.device_codename || 'pdx234' }}
            ./device/sony/sm8550-common
          key: device-${{ github.event.inputs.device_codename }}-${{ github.event.inputs.kernel_branch }}-${{ runner.os }}
          restore-keys: |
            device-${{ github.event.inputs.device_codename }}-

      - name: Clone device trees (if not cached)
        if: steps.cache-device.outputs.cache-hit != 'true'
        run: |
          DEVICE_CODENAME="${{ github.event.inputs.device_codename || 'pdx234' }}"
          KERNEL_BRANCH="${{ github.event.inputs.kernel_branch || 'lineage-22.2' }}"
          mkdir -p device/sony
          git clone https://github.com/LineageOS/android_device_sony_${DEVICE_CODENAME}.git device/sony/${DEVICE_CODENAME}
          git clone https://github.com/LineageOS/android_device_sony_sm8550-common.git device/sony/sm8550-common
          cd device/sony/${DEVICE_CODENAME} && git checkout $KERNEL_BRANCH && cd ../../..
          cd device/sony/sm8550-common && git checkout $KERNEL_BRANCH && cd ../../..

      # 4. 缓存 Android NDK（含Clang工具链，适配Android 14）
      - name: Cache Android NDK (Clang)
        id: cache-ndk
        uses: actions/cache@v3
        with:
          path: ./android-ndk-r26b  # r26b：适配Android 14的稳定版NDK，Clang版本充足
          key: ndk-r26b-clang-${{ runner.os }}
          restore-keys: |
            ndk-r26b-clang-

      - name: Download Android NDK (含Clang)
        if: steps.cache-ndk.outputs.cache-hit != 'true'
        run: |
          # 下载适配Android 14的NDK（r26b，内置Clang 17.0.2，满足内核需求）
          wget https://dl.google.com/android/repository/android-ndk-r26b-linux.zip -O ndk.zip
          unzip ndk.zip  # 解压后自动生成 android-ndk-r26b 目录
          rm -f ndk.zip  # 清理压缩包

  # --------------------------
  # Job 2：NDK Clang编译内核与生成boot.img
  # --------------------------
  compile-bootimg:
    runs-on: ubuntu-22.04
    needs: prepare-dependencies
    steps:
      - name: Checkout main repo
        uses: actions/checkout@v4

      - name: Install Clang build dependencies
        run: |
          sudo apt-get update
          # 安装Clang编译必需依赖（保留多架构支持）
          sudo apt-get install -y bc bison build-essential ccache flex g++-multilib gcc-multilib lib32ncurses5-dev lib32readline-dev lib32z1-dev libelf-dev liblz4-tool libncurses5-dev libssl-dev lzop rsync zip zlib1g-dev

      # 恢复内核源码缓存
      - name: Restore kernel source cache
        uses: actions/cache@v3
        with:
          path: ./kernel
          key: kernel-${{ needs.prepare-dependencies.outputs.kernel_branch }}-${{ needs.prepare-dependencies.outputs.device_codename }}-${{ needs.prepare-dependencies.outputs.build_type }}-${{ runner.os }}

      # 恢复设备树缓存
      - name: Restore device trees cache
        uses: actions/cache@v3
        with:
          path: |
            ./device/sony/${{ needs.prepare-dependencies.outputs.device_codename }}
            ./device/sony/sm8550-common
          key: device-${{ needs.prepare-dependencies.outputs.device_codename }}-${{ needs.prepare-dependencies.outputs.kernel_branch }}-${{ runner.os }}

      # 恢复NDK并配置Clang路径
      - name: Restore Android NDK (Clang)
        uses: actions/cache@v3
        with:
          path: ./android-ndk-r26b
          key: ndk-r26b-clang-${{ runner.os }}

      - name: Configure NDK Clang Path (Force Enable)
        run: |
          # NDK中Clang工具链的绝对路径（r26b目录结构固定）
          NDK_CLANG_PATH=$(pwd)/android-ndk-r26b/toolchains/llvm/prebuilt/linux-x86_64/bin
          
          # 验证Clang是否存在（强制检查，避免路径错误）
          if [ ! -f "$NDK_CLANG_PATH/clang" ] || [ ! -f "$NDK_CLANG_PATH/aarch64-linux-android-clang" ]; then
            echo "Error: Clang not found in NDK! Path: $NDK_CLANG_PATH"
            ls -l $NDK_CLANG_PATH  # 显示目录内容便于调试
            exit 1
          fi
          
          # 添加Clang到PATH（优先级最高）
          echo "PATH=$NDK_CLANG_PATH:$PATH" >> $GITHUB_ENV
          
          # 验证Clang版本（需≥14.0.0，r26b自带17.0.2，满足lineage-22.2需求）
          CLANG_VERSION=$($NDK_CLANG_PATH/clang --version | grep -oP 'version \K\d+\.\d+\.\d+')
          echo "Found Clang version: $CLANG_VERSION"
          if [[ $(echo "$CLANG_VERSION >= 14.0.0" | bc -l) -eq 0 ]]; then
            echo "Error: Clang version too old! Need ≥14.0.0"
            exit 1
          fi

      # 用NDK Clang强制编译内核（核心步骤）
      - name: Build kernel with NDK Clang (Forced)
        run: |
          cd kernel
          # 1. 基础架构配置
          export ARCH=arm64
          # 2. 交叉编译工具链前缀（NDK内置，与Clang匹配）
          export CROSS_COMPILE=aarch64-linux-android-
          export CROSS_COMPILE_ARM32=arm-linux-androideabi-
          # 3. 强制指定Clang相关工具（覆盖所有可能的GCC干扰）
          export CC=aarch64-linux-android-clang  # NDK专用Clang前端
          export LD=aarch64-linux-android-ld.lld  # Clang配套链接器
          export AR=aarch64-linux-android-llvm-ar
          export NM=aarch64-linux-android-llvm-nm
          export OBJCOPY=aarch64-linux-android-llvm-objcopy
          export OBJDUMP=aarch64-linux-android-llvm-objdump
          export STRIP=aarch64-linux-android-llvm-strip
          # 4. 清除残留的GCC环境变量（双重保险）
          unset GCC CCACHE_COMPILER
          
          # 5. 加载设备专属defconfig（必须指定设备代号，原defconfig可能不存在）
          make O=out defconfig
          
          # 6. 启用SukiSU配置（若为with_sukisu版本）
          if [ "${{ needs.prepare-dependencies.outputs.build_type }}" = "with_sukisu" ]; then
            # 强制开启SukiSU配置（根据实际配置项调整，此处兼容KernelSU命名）
            make O=out menuconfig KCONFIG_CONFIG=out/.config -e CONFIG_KERNEL_SU=y CONFIG_KERNEL_SU_MODULES=y
          fi
          
          # 7. 开始编译（-j$(nproc) 自动利用所有CPU核心）
          make O=out -j$(nproc)

      # 生成ramdisk
      - name: Prepare ramdisk
        run: |
          DEVICE_CODENAME="${{ needs.prepare-dependencies.outputs.device_codename }}"
          mkdir -p ramdisk
          cp -r device/sony/${DEVICE_CODENAME}/ramdisk/* ramdisk/
          cd ramdisk && find . | cpio -o -H newc | lz4 -l -12 -f - ../ramdisk.img && cd ..

      # 打包boot.img
      - name: Build boot.img
        run: |
          DEVICE_CODENAME="${{ needs.prepare-dependencies.outputs.device_codename }}"
          KERNEL_BRANCH="${{ needs.prepare-dependencies.outputs.kernel_branch }}"
          BUILD_TYPE="${{ needs.prepare-dependencies.outputs.build_type }}"
          
          # 下载mkbootimg工具（适配Android 14的boot.img格式）
          wget https://github.com/osm0sis/mkbootimg/releases/latest/download/mkbootimg -O mkbootimg
          chmod +x mkbootimg
          
          # 产物名含NDK Clang标识，明确编译环境
          if [ "$BUILD_TYPE" = "with_sukisu" ]; then
            OUTPUT_NAME="boot-${DEVICE_CODENAME}-${KERNEL_BRANCH}-ndk-clang-sukisu-v${{ env.SUKISU_VERSION }}.img"
          else
            OUTPUT_NAME="boot-${DEVICE_CODENAME}-${KERNEL_BRANCH}-ndk-clang-original.img"
          fi
          
          # 打包boot.img（参数与LineageOS官方保持一致）
          ./mkbootimg \
            --kernel kernel/out/arch/arm64/boot/Image.gz-dtb \
            --ramdisk ramdisk.img \
            --base 0x00000000 \
            --cmdline "video=vfb:640x400,bpp=32,memsize=3072000 nosoftlockup" \
            --bootconfig "androidboot.hardware=qcom androidboot.memcg=1 androidboot.usbcontroller=a600000.dwc3" \
            --pagesize 4096 \
            --ramdiskoffset 0x01000000 \
            --tagsoffset 0x00000100 \
            --headerversion 4 \
            --osversion 14 \
            --ospatchlevel 2025-04 \
            --output $OUTPUT_NAME

      # 上传产物
      - name: Upload boot.img
        uses: actions/upload-artifact@v4
        with:
          name: boot-image-${{ needs.prepare-dependencies.outputs.device_codename }}-ndk-clang-${{ needs.prepare-dependencies.outputs.build_type }}
          path: boot-${{ needs.prepare-dependencies.outputs.device_codename }}-*.img
